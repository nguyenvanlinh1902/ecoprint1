---
description: 
globs: 
alwaysApply: false
---
# Frontend Development Rules and Best Practices

This document outlines the rules, patterns, and best practices for frontend development in our application.

## Architecture Overview

Our frontend application follows the Atomic Design methodology with a clean, structured architecture:

```
src/
  ├── main.js             # Entry point for the application
  ├── App.js              # Root component
  ├── components/         # Reusable UI components
  │   ├── atoms/          # Basic components (Button, Input, Label)
  │   ├── molecules/      # More complex components (FormField, SearchBar)
  │   ├── organisms/      # Large combined components (Header, Sidebar, ProductList)
  │   └── ...             # Other functional components
  ├── pages/              # Application pages
  ├── layouts/            # Page layouts
  ├── routes/             # Routing
  ├── contexts/           # Context API for state management
  ├── hooks/              # Custom React hooks
  ├── helpers/            # Utility functions
  ├── config/             # Configuration
  ├── const/              # Constants
  ├── styles/             # CSS/SCSS
  ├── resources/          # Resources (images, icons)
  └── loadable/           # Code splitting components
```

## Core Principles

1. **Atomic Design**: Use Atomic Design methodology for component organization
2. **Component-Based**: Create reusable and independent components
3. **Separation of Concerns**: Separate UI and logic
4. **Responsive Design**: Ensure UI works well on all screen sizes

## Technologies

1. **React**: Main UI framework
2. **Vite**: Build tool for fast development
3. **Material UI**: UI component library following Material Design principles
4. **React Router**: Handling application routing
5. **Axios**: HTTP client for API requests
6. **SCSS with BEM**: Styling following BEM methodology

## File Extensions and Naming Rules

### Required Extensions

1. **Component Files**:
   - `.js`: Use for all React components, utility functions, and configurations
   - Follow PascalCase for component names (e.g., `Button.js`, `ProductCard.js`)

2. **Style Files**:
   - `.scss`: Use for all styling files
   - Match component names (e.g., `Button.scss` for `Button.js`)
   - Follow BEM methodology for class names

3. **Test Files**:
   - `.test.js`: For unit and integration tests
   - Name should match the file being tested (e.g., `Button.test.js`)

4. **Type Definition Files**:
   - Avoid using TypeScript definitions
   - Use JSDoc comments for documenting types

5. **Asset Files**:
   - `.svg`: Vector graphics (preferred format)
   - `.png`: Raster images when necessary
   - `.jpg`: Photos and complex images
   - `.webp`: Optimized web images (preferred for photos)

6. **Configuration Files**:
   - `.json`: For static configuration
   - `.js`: For dynamic configuration

## Component Structure Rules

### Folder Organization

Each component should be organized in its own folder:

```
ComponentName/
  ├── index.js           # Export component
  ├── ComponentName.js   # Component implementation
  ├── ComponentName.scss # Component styles
  ├── ComponentName.test.js # Component tests
  └── components/        # Sub-components (if needed)
```

### Component Implementation

```js
// Button.js - Example component structure
import React from 'react';
import PropTypes from 'prop-types';
import './Button.scss';

export function Button({ variant, onClick, isLoading, children, className, ...rest }) {
  // BEM class naming
  const baseClass = 'button';
  const modifierClass = variant ? `${baseClass}--${variant}` : '';
  const loadingClass = isLoading ? `${baseClass}--loading` : '';
  
  const combinedClassName = [
    baseClass,
    modifierClass,
    loadingClass,
    className
  ].filter(Boolean).join(' ');
  
  return (
    <button 
      className={combinedClassName}
      onClick={onClick}
      disabled={isLoading}
      {...rest}
    >
      {isLoading ? <span className="button__spinner" /> : null}
      <span className="button__content">{children}</span>
    </button>
  );
}

// Define prop types
Button.propTypes = {
  variant: PropTypes.oneOf(['contained', 'outlined', 'text']),
  onClick: PropTypes.func,
  isLoading: PropTypes.bool,
  children: PropTypes.node.isRequired,
  className: PropTypes.string
};

export default Button;
```

## Styling Rules with BEM

### BEM Naming Convention

```scss
// Button.scss - Example BEM structure
.button {
  // Base styles for the button
  padding: 8px 16px;
  
  // Elements (use &__element-name)
  &__content {
    display: inline-block;
  }
  
  &__spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
  }
  
  // Modifiers (use &--modifier-name)
  &--contained {
    background-color: #1976d2;
    color: white;
  }
  
  &--outlined {
    background-color: transparent;
    color: #1976d2;
    border: 1px solid currentColor;
  }
  
  // State modifiers
  &--loading {
    opacity: 0.7;
    cursor: not-allowed;
  }
}
```

## Material UI Integration

### Theme Configuration

```javascript
// src/theme.js - Example theme configuration
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#9c27b0',
    }
  },
  // Other theme configurations
});

export default theme;
```

## API Hook Rules

### Base API Call Pattern

```javascript
// services/api.js - Base API utilities
import axios from 'axios';

export async function api(url, options = {}) {
  const { body, method = 'GET', headers = {}, ...rest } = options;
  
  try {
    const token = localStorage.getItem('authToken');
    
    const defaultHeaders = {
      'Content-Type': 'application/json',
      ...(token ? { 'Authorization': `Bearer ${token}` } : {})
    };
    
    const response = await axios({
      url: `/api/${url}`,
      method,
      headers: { ...defaultHeaders, ...headers },
      data: body,
      ...rest
    });
    
    return response.data;
  } catch (error) {
    // Error handling
    return { success: false, error: error.message };
  }
}
```

### Custom API Hooks

```javascript
// hooks/api/useFetchApi.js - Example of a fetch hook
import { useState, useEffect, useCallback } from 'react';
import { api } from '@/services/api';

export default function useFetchApi({
  url,
  defaultData = null,
  initLoad = false,
  initQueries = {},
  presentData = data => data,
  successCallback = () => {}
}) {
  const [data, setData] = useState(defaultData);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [count, setCount] = useState(0);
  
  const fetchApi = useCallback(async (endpoint = url, queries = {}) => {
    setLoading(true);
    setError(null);
    
    try {
      const queryString = new URLSearchParams(queries).toString();
      const fullUrl = queryString ? `${endpoint}?${queryString}` : endpoint;
      
      const response = await api(fullUrl);
      
      if (response.success === false) {
        throw new Error(response.error);
      }
      
      const processedData = presentData(response.data || response);
      setData(processedData);
      
      if (response.count !== undefined) {
        setCount(response.count);
      }
      
      successCallback(processedData);
      return processedData;
    } catch (err) {
      setError(err.message);
      return null;
    } finally {
      setLoading(false);
    }
  }, [url, presentData, successCallback]);
  
  useEffect(() => {
    if (initLoad) {
      fetchApi(url, initQueries);
    }
  }, [fetchApi, url, initLoad]);
  
  return {
    data,
    loading,
    error,
    fetchApi,
    count
  };
}
```

## Testing Rules

### Component Testing

```js
// Button.test.js - Example test structure
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

describe('Button Component', () => {
  test('renders with children', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
  
  test('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  test('displays loading state', () => {
    render(<Button isLoading>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
});
```

## Performance Optimization Rules

1. **Code Splitting**:
   - Use React.lazy and Suspense for component code splitting
   - Implement route-based code splitting for pages

2. **Component Optimization**:
   - Use React.memo for pure functional components
   - Implement useCallback for event handlers
   - Use useMemo for expensive calculations

3. **Bundle Size Management**:
   - Monitor bundle size with performance tools
   - Import only needed components from libraries
   - Use tree-shaking friendly imports

4. **Image Optimization**:
   - Use WebP format where possible
   - Implement responsive images with srcset
   - Lazy load images below the fold

## Accessibility Rules

1. **Semantic HTML**:
   - Use proper HTML elements (button for actions, a for links)
   - Implement appropriate heading hierarchy (h1-h6)

2. **Keyboard Navigation**:
   - Ensure all interactive elements are keyboard accessible
   - Implement focus states for keyboard users

3. **ARIA Attributes**:
   - Use aria-* attributes when semantic HTML is not enough
   - Implement aria-live regions for dynamic content

4. **Color Contrast**:
   - Maintain WCAG AA standard (4.5:1 for normal text)
   - Don't rely on color alone to convey information


Client Request → API Handler → Routes → Controllers → Services/Repositories → Firestore/External APIs
index.js: Defines HTTP endpoints and Pub/Sub triggers
handlers/api.js: Sets up Koa.js application with middleware, error handling, and route registration
routes/api.js: Maps URL paths to specific controller methods
controllers/: Execute business logic and interact with repositories/services
repositories/: Provide CRUD operations on Firestore collections

# KoaJS Development Rules and Best Practices

This document outlines the rules, patterns, and best practices for developing with KoaJS in our functions architecture.

## Architecture Overview

Kiến trúc serverless functions của chúng ta tuân theo mô hình phân lớp rõ ràng, mỗi thư mục đóng một vai trò cụ thể và có trách nhiệm riêng biệt. Cấu trúc này giúp dễ dàng mở rộng, bảo trì và kiểm thử.

```
src/
  ├── index.js            # Điểm khởi chạy chính của Firebase Functions
  ├── handlers/           # Xử lý các ứng dụng Koa, điều phối request
  ├── routes/             # Định nghĩa các đường dẫn API và phương thức
  ├── controllers/        # Xử lý request và định dạng response
  ├── services/           # Xử lý logic nghiệp vụ chính
  ├── repositories/       # Tương tác với cơ sở dữ liệu
  ├── middleware/         # Các middleware tái sử dụng
  ├── helpers/            # Các hàm tiện ích
  ├── config/             # Cấu hình ứng dụng
  ├── const/              # Các hằng số
  └── exceptions/         # Định nghĩa lỗi tùy chỉnh
```

### Vai trò chi tiết của các thư mục:

- **index.js**: Điểm khởi đầu, nơi đăng ký các Firebase Functions
- **handlers/**: Chứa các ứng dụng Koa, nơi khởi tạo middleware và routes
- **routes/**: Định nghĩa các endpoint API và kết nối chúng với controllers
- **controllers/**: Xử lý input từ request, gọi services, và định dạng response
- **services/**: Chứa toàn bộ logic nghiệp vụ, độc lập với framework
- **repositories/**: Trừu tượng hóa việc truy cập database, thực hiện CRUD
- **middleware/**: Các hàm xử lý trung gian như xác thực, phân quyền, kiểm tra input
- **helpers/**: Các tiện ích phổ biến dùng trong ứng dụng
- **config/**: Cấu hình cho Firebase, database và các dịch vụ khác
- **const/**: Các giá trị không thay đổi như mã lỗi, trạng thái
- **exceptions/**: Các lớp lỗi tùy chỉnh để xử lý ngoại lệ

## Core Principles

1. **Separation of Concerns**: Each layer has a specific responsibility
2. **Single Responsibility**: Each file should do one thing well
3. **Dependency Injection**: Dependencies should be passed in, not imported directly when possible
4. **Async/Await**: Use modern async/await syntax instead of callbacks or promise chains
5. **Error Handling**: Centralized error handling with proper logging and client-friendly messages

## KoaJS Setup Rules

### Application Setup

```javascript
// Create Koa application instance
const api = new App();
api.proxy = true;

// Register global middleware (executed in order)
api.use(createErrorHandler());
api.use(authMiddleware());
api.use(corsMiddleware());

// Register routes
const router = apiRouter();
api.use(router.allowedMethods());
api.use(router.routes());
```

### Middleware Development

1. **Middleware Function Signature**: Factory function returning async middleware
2. **Error Handling Middleware**: Catch errors and format responses

## Routing Rules

1. **Route Organization**:
   - Group routes by feature or resource
   - Use prefixes to segment API
   - Export router factory functions
   - Use HTTP verbs correctly (GET, POST, PUT, PATCH, DELETE)

## Controller Rules

1. **Keep Controllers Thin**:
   - Focus on request/response handling
   - Delegate business logic to services
   - Extract validation to separate middleware

## Service Rules

1. **Business Logic Encapsulation**:
   - Services contain all business logic
   - Independent from web framework
   - Can be unit tested in isolation

## Repository Rules

1. **Data Access Abstraction**:
   - Repositories abstract all database operations
   - Return business entities, not DB models
   - Hide database implementation details

## Error Handling Rules

1. **Custom Error Classes**:
   - Define custom errors for different scenarios
   - Include HTTP status codes
   - Provide user-friendly messages

2. **Centralized Error Logging**:
   - Log errors with request context
   - Include request ID for traceability

## Firebase Functions Integration

1. **Exporting Koa Apps as Functions**: Use proper function export syntax
2. **Function Configuration**: Configure memory, timeout as needed

## Testing Guidelines

1. **Unit Testing**:
   - Test services and repositories in isolation
   - Mock dependencies
   - Focus on business logic

2. **Integration Testing**:
   - Test API endpoints with supertest
   - Use test database
   - Validate response structure

## Performance Best Practices

1. **Avoid Blocking Operations**
2. **Use Promise.all for Concurrent Operations**
3. **Implement Proper Caching Strategies**
4. **Optimize Database Queries**
5. **Minimize Function Cold Starts**

## Security Guidelines

1. **Validate All Input**
2. **Use Middleware for Authentication**
3. **Implement Proper CORS Settings**
4. **Apply Rate Limiting**
5. **Set Appropriate Response Headers**

## Deployment Checklist

1. **Remove Development Code**
2. **Set Environment Variables**
3. **Configure Proper Memory Allocation**
4. **Set Timeouts Appropriately**
5. **Enable Logging and Monitoring**

## Firebase Integration Guidelines

### Firebase Admin SDK Setup

- Initialize Firebase Admin SDK properly
- Export utility functions for Firestore, Storage access

### Firestore Data Access Pattern

- Follow Repository pattern for database operations
- Implement CRUD operations consistently
- Handle errors appropriately

### Authentication Middleware

- Verify Firebase ID tokens
- Set user context for downstream middleware
- Return appropriate status codes for auth failures

### Role-Based Authorization

- Implement role checks in middleware
- Support multiple roles when needed
- Return clear permission denied messages

### Firebase Storage Usage

- Implement secure file upload/download
- Generate unique filenames
- Set appropriate metadata and caching

### Firebase Cloud Functions

- Configure function resources appropriately
- Implement event triggers (Firestore, Auth, etc.)
- Create scheduled functions when needed


